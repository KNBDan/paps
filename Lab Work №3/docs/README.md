# Лабораторная работа №3
## Тема:
Использование принципов проектирования на уровне методов и классов
## Цель работы: 
Получить опыт проектирования и реализации модулей с использованием принципов KISS, YAGNI, DRY, SOLID и др.
## Диаграмма контейнеров
![c2](/images/c2.png)
Диаграмма контейнеров

## Диаграмма компонентов
![c3.2](/images/c3(2).png)

Диаграмма компонентов для telegram admin backend блока.  
Компоненты отвечают за отдельные действия, будь то генерация кодов для волонтеров или оценка заданий пользователя, запуск голосований и заданий. Весь функционал распределен по принципу одни по смыслу действия - отдельный компонент. 

## Диаграмма последовательностей
![cases](/images/cases.png)

На диаграмме показано взаимодействие администратора с системой через тг бот. Все команды администратора проходят через бот и отправляются в административный backend, который выполняет нужные операции и при необходимости обновляет данные в базе.

## Модель БД
![db](/images/db.png)
База данных включает основные таблицы, необходимые для работы Telegram-бота конференции. Таблица users хранит информацию о студентах, волонтёрах и администраторах, включая их роли, контактные данные и статус участия. 
Таблицы task и completed_user_task отвечают за задания и результаты их выполнения: первая содержит описание задания, а вторая отмечает, какой пользователь и когда его завершил.

Для учёта посещаемости используется таблица visit, куда система добавляет запись после сканирования QR-кода волонтёром. 
Активности мероприятия описываются в таблице activity, а связанные с ними события, такие как голосования или мини-квизы - в activity_event. 
Механизм голосований реализован через таблицу vote, где хранятся ответы пользователей.

Дополнительно используются вспомогательные таблицы, такие как auth_code для хранения кодов авторизации волонтёров и company для данных о партнёрах мероприятия.

## Применение основных принципов разработки
(Код не всегда относится к вышеуказанному контейнеру)
### KISS
Каждая функция должна решать одну конкретную задачу.
```kotlin
fun getUser(userId: Long): User {
    val user = userStorage.getUser(userId)
        ?: throw UserByIdNotFoundException(userId)
    return user
}
```
### DRY
Повторяющийся код вынесен в функцию.
```kotlin
fun generateCompanyCode(): String {
    return "UNC" + generateCode()
}

fun generateActivityCode(): String {
    return "UNA" + generateCode()
}

fun generateUserCode(): String {
    return "UNU" + generateCode()
}

private fun generateCode(): String {
    return buildString {
        repeat(CODE_LENGTH) {
            append(CHARACTERS[random.nextInt(CHARACTERS.length)])
        }
    }
}
```
### YAGNI
Все новые методы и функции добавляются только по мере надобности. Есть план - архитектура, к которому мы стремимся и если что-то потребуется - тогда и реализуем
### SOLID
#### S, O
Новый вид ошибок, просто новый класс, при этом под ошибки выделен отдельные классы:
```kotlin
abstract class NotFoundException(
    entityName: String,
    override val message: String,
) 

class CompanyByIdNotFoundException(
    companyId: Long,
) : NotFoundException(
    "Company",
    "Company with id $companyId not found"
)

class EventByIdNotFoundException(
    id: Long
) : NotFoundException(
    "Event",
     "Event with id $id not found"
)
```

#### L
Вместо специфичной ошибки отсутствии пользователя, можно подставить базовую ошибку с отсутсвием объекта NotFoundException()
```kotlin
val user = userStorage.getUser(userId)
    ?: throw UserByIdNotFoundException(userId)
```

#### I
Интерфейс UserStorage конкретно работает с классом User, для всех остальных entity созданы отдельные Storage для более простого восприятия и упрощения чтения кода.
```kotlin
interface UserStorage {
    fun getUsers(
        limit: Int = 1000,
        token: Long = 0,
    ): Pageable<User>

    fun getUser(
        id: Long
    ): User?
}
```
#### D
В данном случае мы не зависим от конкретного класса, мы его один раз определяем при создании сервиса и потом используем в классе. Можно легко изменить прявязку к тестовому или другому Storage, методы останутся теми же.
```kotlin
class UserService(
    private val userStorage: UserStorage
) {
    fun getUser(userId: Long): User {
        val user = userStorage.getUser(userId)
            ?: throw UserByIdNotFoundException(userId)
        return user
    }
}
```

## Дополнительные принципы разработки
### BDUF - не используем
Проект развивается поэтапно, по мере надобности пишутся классы. Масштабное планирование в рамках проекта излишне.
### SoC - используем
Принцип разделения ответственности должна быть соблюдена: логика разбита на модули (отдельные сервисы для разных объектов по типу пользователи, задания, кампании, отдельно репозитории для обращения к бд для каждого объекта и тп)
### MVP - используем
Должен быть реализован базовый функционал: регистрация, сканер, отметка куар кодов, выполнение заданий и голосование. Удобное логирование, доп функции с предоставлением статистики и прочее реализуются при уверенности в сроках выполнения.
### PoC - используем
Должны быть заранее протестированы подходящие базы данных, принцип генерации куар кодов, работа телеграмм Api и прочее, чтобы в дальнейшей разработке не было проблем с этим.   